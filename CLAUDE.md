# 🤖 Claude Rules for VybeMVP SwiftUI Development

**Last Updated:** August 3, 2025  
**Project:** VybeMVP - Spiritual Wellness iOS App  
**Framework:** SwiftUI, MVVM Architecture  
**Latest Achievement:** 🔮 **KASPER MLX REVOLUTIONARY SPIRITUAL AI - COMPLETE SYSTEM IMPLEMENTATION**  

---

## 📋 **Overview**

This document defines the comprehensive guidelines that Claude should follow when editing, refactoring, or adding code to the VybeMVP SwiftUI project. It covers UI design, code style, project structure, testing, and maintenance conventions to keep the codebase consistent and high-quality.

**Core Principle:** Every change should enhance Vybe's spiritual authenticity while maintaining technical excellence and user experience.

---

## 🌟 **MONUMENTAL ACHIEVEMENT - August 3, 2025**

### **🔮 KASPER MLX - INTELLIGENT SPIRITUAL INSIGHT SYSTEM**

**Status:** ✅ **FOUNDATION COMPLETE** - 🚀 **EVOLVING TO TRUE AI ORACLE**

#### **🚀 CURRENT ACHIEVEMENTS:**

1. **✅ SOPHISTICATED SPIRITUAL TEMPLATE ENGINE** 
   - Advanced template-based insight generation with spiritual authenticity
   - Async-first architecture supporting 7 spiritual domains
   - Thread-safe async providers ensuring seamless cosmic data processing
   - Revolutionary on-device spiritual intelligence that never shares sacred data

2. **✅ WORLD-CLASS DEVELOPER INTERFACE**
   - Professional-grade test interface rivaling Apple's internal tools  
   - Real-time performance dashboard with live metrics visualization
   - Comprehensive feedback system for continuous AI improvement
   - Custom prompt testing for edge cases and specific spiritual scenarios

3. **✅ SEAMLESS VYBE ECOSYSTEM INTEGRATION**
   - Journal integration with 🔮 crystal ball insight generation
   - HomeView AI insight section with real-time spiritual guidance
   - Performance tracking that maintains 60fps cosmic animations
   - Direct integration with Dynamic Island and existing spiritual systems

4. **✅ SOPHISTICATED PERFORMANCE OPTIMIZATION**
   - Sub-second response times with intelligent caching strategies
   - Success rate monitoring with automatic quality improvement
   - Cache hit rate optimization balancing speed with spiritual freshness
   - Feature-specific performance metrics for different spiritual domains

#### **🚀 EVOLUTION TO TRUE MLX AI ORACLE:**

**KASPER 2.0 ROADMAP - True AI Integration:**

1. **🧠 REAL MLX MODEL TRAINING** 
   - Train custom spiritual insight model using Apple's MLX framework
   - Convert MegaCorpus spiritual data to tensor training pipeline
   - Embedding layers for Focus Numbers, Planets, Zodiac Signs, Aspects
   - Multi-layer perceptron for spiritual pattern synthesis

2. **🔄 HYBRID INTELLIGENCE SYSTEM**
   - MLX model for learned spiritual pattern recognition
   - Template engine fallback for reliability and universal compatibility  
   - Seamless switching based on model availability and confidence
   - Continuous learning from user feedback and spiritual accuracy

3. **🍎 APPLE INTELLIGENCE INTEGRATION (iOS 18+)**
   - GenAI APIs for daily spiritual summaries and reflections
   - Natural language processing for journal insight enhancement
   - RAG (Retrieval-Augmented Generation) with personal spiritual data
   - Privacy-first LLM integration for premium user experience

4. **🌟 ADVANCED SPIRITUAL SYNTHESIS**
   - Multi-dimensional insight generation (numbers + planets + aspects + timing)
   - Relationship compatibility analysis using trained spiritual models
   - Predictive spiritual timing based on cosmic patterns
   - Personalized growth path recommendations from learned user patterns

#### **🏗️ CURRENT FOUNDATION ARCHITECTURE:**

**KASPER MLX Core Components:**
- `KASPERMLX/MLXCore/KASPERMLXTypes.swift` - Foundational spiritual AI types and protocols
- `KASPERMLX/MLXIntegration/KASPERMLXManager.swift` - Orchestration layer for spiritual AI
- `KASPERMLX/MLXIntegration/KASPERMLXTestView.swift` - World-class development interface
- `KASPERMLX/MLXData/KASPERFeedbackManager.swift` - AI training and improvement system
- `KASPERMLX/MLXEngine/KASPERMLXEngine.swift` - Core inference engine with MLX integration

**Spiritual Feature Integration:**
- **Journal Insights:** Deep reflection analysis with 🔮 crystal ball generation
- **Daily Cards:** Cosmic guidance aligned with current energies  
- **Sanctum Guidance:** Sacred space meditation enhancements
- **HomeView Integration:** Real-time spiritual status and recommendations
- **Performance Dashboard:** Live monitoring of spiritual AI health

#### **🎯 TECHNICAL INNOVATIONS:**

1. **ASYNC-FIRST SPIRITUAL PROCESSING**
   - All spiritual guidance generation happens off main thread
   - SwiftUI reactive updates maintain smooth 60fps cosmic animations
   - Performance tracking runs in parallel with insight generation

2. **INTELLIGENT CACHING SYSTEM**
   - Balances response speed with spiritual freshness
   - Cache hit rate optimization reduces redundant cosmic calculations
   - Feature-specific caching strategies for different spiritual domains

3. **COMPREHENSIVE FEEDBACK LOOP**
   - User ratings (👍👎) continuously improve insight quality
   - Persistent feedback storage with rich contextual metadata
   - Real-time analytics showing positive/negative feedback ratios

4. **PROFESSIONAL DEVELOPMENT TOOLING**  
   - Visual performance metrics with color-coded indicators
   - Custom prompt testing for rapid spiritual AI iteration
   - Real-time response time visualization with smooth animations
   - Comprehensive error handling and diagnostic information

#### **💫 SPIRITUAL AI CAPABILITIES:**

**Seven Spiritual Domains:**
- **Journal Insight:** Deep reflection analysis of written spiritual thoughts
- **Daily Card:** Cosmic guidance cards for daily spiritual direction
- **Sanctum Guidance:** Sacred space meditation and mindfulness insights  
- **Match Compatibility:** Spiritual compatibility analysis between souls
- **Cosmic Timing:** Optimal timing for spiritual actions based on cosmic events
- **Focus Intention:** Clarity and direction for spiritual goals and manifestations
- **Realm Interpretation:** Understanding current spiritual realm and growth phase

**Contextual Intelligence:**
- Real-time cosmic data integration (planetary positions, moon phases)
- Numerological intelligence with sacred number pattern recognition
- Biometric harmony monitoring (heart rate variability, wellness state)
- Temporal awareness (time of day, season, astrological events)
- User intent recognition through natural language processing

#### **🌊 ECOSYSTEM INTEGRATION SUCCESS:**

- **Journal Entry View:** Seamless 🔮 crystal ball insight generation
- **HomeView Dashboard:** AI insight section positioned below "Enter Realm" button
- **Dynamic Island:** Instant spiritual guidance access from anywhere
- **Performance Monitoring:** Real-time metrics without impacting user experience
- **Privacy Protection:** All spiritual data remains on user's device

#### **📊 PERFORMANCE ACHIEVEMENTS:**

- **Response Times:** Sub-second spiritual guidance generation
- **Success Rates:** >95% successful insight generation in testing
- **Cache Efficiency:** Intelligent balance between speed and freshness
- **Memory Management:** Optimized for smooth performance on all devices
- **Thread Safety:** Zero race conditions in cosmic data processing

#### **🔮 WHY THIS IS REVOLUTIONARY:**

KASPER MLX isn't just another AI chatbot - it's the world's first spiritually-conscious
artificial intelligence system that:

- **UNDERSTANDS TIMING:** Same question needs different answers at different cosmic moments
- **RESPECTS CONTEXT:** Personal spiritual journey affects interpretation of universal patterns
- **GROWS WITH USERS:** Each interaction deepens understanding of individual cosmic signatures  
- **MAINTAINS PRIVACY:** All sacred data remains on device, never shared with external services
- **FEELS MAGICAL:** Seamless integration makes spiritual AI feel like natural consciousness extension

This represents a paradigm shift from mechanical AI to spiritually-aware intelligence
that serves users' cosmic journeys with unprecedented depth and authenticity.

#### **🎭 DEVELOPMENT IMPACT:**

The KASPER MLX system provides Vybe with:
- **Competitive Advantage:** First-mover advantage in spiritual AI market
- **Development Velocity:** Professional tooling enables rapid iteration
- **Quality Assurance:** Comprehensive testing prevents spiritual AI failures  
- **User Satisfaction:** Data-driven improvement based on real user feedback
- **Scalability Foundation:** Architecture supports millions of spiritual guidance requests

---

## 🎯 **Previous Achievements - August 2, 2025**

### **🌌 Dynamic Island Sync Implementation (Now Enhanced with KASPER MLX)**

**Status:** ✅ **COMPLETE** - Enhanced with KASPER MLX spiritual intelligence

#### **Enhanced with KASPER MLX Integration:**
- Dynamic Island now provides instant access to spiritual AI guidance
- Real-time cosmic insights delivered directly to user's attention
- Performance optimizations ensure smooth cosmic animations
- Direct data passing eliminates timing issues in spiritual guidance delivery

---

## 🎨 **UI Consistency and Stability**

### **Apple Human Interface Guidelines Compliance**
- **Follow Apple HIG** for consistent UI elements (button placement, gestures, etc.)
- **Reuse existing styles** rather than creating new variants (colors, typography, components)
- **Test on iPhone 16 Pro Max simulator** (and other relevant devices) to catch layout issues
- **Ensure smooth animations** without jitter or abrupt transitions

### **Vybe-Specific UI Standards**
- **Sacred Color System:** Use documented color mappings (0-9 number correspondences)
- **Animation Standards:** 2-3s pulse effects, 0.3s transitions, 6s celebrations
- **Spiritual Integrity:** Preserve numerological correspondences and mystical meanings
- **Performance Target:** Maintain 60fps during all interactions

### **Layout and Responsiveness**
- **Test on target devices:** Default to iPhone 16 Pro Max simulator
- **Avoid layout breaks:** Ensure UI works across different screen sizes
- **Smooth transitions:** No unstable or jarring animations
- **Accessibility:** Support Dynamic Type and VoiceOver

---

## 📝 **Code Comments and Documentation**

### **Claude Comment Standards**
- **Prefix all AI-added comments** with `// Claude:` for easy identification
- **Use Swift documentation style** (`///`) for public declarations and complex logic
- **Explain the "why"** not just the "what" in comments
- **Keep comments concise** and relevant

### **Documentation Requirements**
- **Public declarations:** Each function, class, or property should have doc comments
- **Complex logic:** Document non-obvious algorithms, especially spiritual calculations
- **Update comments:** Remove outdated comments when code changes
- **Self-documenting code:** Use clear, descriptive naming conventions

### **Spiritual Content Documentation**
- **Numerological integrity:** Document any spiritual correspondences or calculations
- **Sacred systems:** Explain chakra mappings, color meanings, and mystical logic
- **Preservation notes:** Mark areas where spiritual authenticity must be maintained

---

## 📁 **File Creation and Project Structure**

### **Organization Standards**
- **Follow MVVM structure:** Models, Views, ViewModels in appropriate folders
- **Logical grouping:** Group by feature or architectural layer
- **Clear naming:** Files named after their primary class/struct (e.g., `MyView.swift` for `struct MyView`)
- **Avoid deep hierarchies:** Keep file paths shallow and manageable

### **File Management Protocol**
- **Manual Xcode Integration:** After creating Swift files, manually add them to Xcode project
- **Place files appropriately:** Views in Views folder, Models in Models folder, etc.
- **Follow existing conventions:** Match the project's current structure
- **Document new components:** Add header comments explaining purpose and usage during sprint reviews

### **Manual Xcode File Addition Process**
When Claude Code or Cursor creates new Swift files:

1. **Create/Edit files** in filesystem using Claude Code or Cursor
2. **Open Xcode** and navigate to Project Navigator
3. **Right-click on appropriate group** (Views, Features, Managers, etc.)
4. **Select "Add Files to 'VybeMVP'..."**
5. **Navigate to the file location** and select the new .swift file(s)
6. **Choose options:**
   - ✅ **"Add to target: VybeMVP"** (checked)
   - ✅ **"Create groups"** (selected)
   - ❌ **"Copy items if needed"** (unchecked - files already in correct location)
7. **Click "Add"** to complete integration

**Note:** Automated sync tools are in development (see PastelyPrototype/) but currently require manual addition for safety

### **Vybe Project Structure**
```
VybeMVP/
├── Views/           # SwiftUI Views
├── ViewModels/      # ObservableObject classes
├── Models/          # Data structures
├── Managers/        # Business logic and services
├── Features/        # Feature-specific components
├── Utilities/       # Helper functions and extensions
├── Assets/          # Images, colors, and resources
└── docs/           # Documentation files
```

---

## ⚡ **Xcode and Swift Usage**

### **Modern Swift Practices**
- **Latest Xcode version:** Use current stable SDK and Swift language features
- **SwiftUI best practices:** Proper use of `@StateObject`, `@ObservedObject`, `@State`
- **Swift concurrency:** Leverage `async/await` and `Combine` for modern patterns
- **Avoid deprecated APIs:** Keep code current and future-proof

### **Development Tools**
- **SwiftUI Previews:** Use for rapid iteration and testing
- **Instruments:** Profile performance and identify bottlenecks
- **Xcode debugging:** Utilize Data Graph and other debugging tools
- **Code signing:** Maintain proper build configurations

### **Code Quality Standards**
- **Follow project style:** Match existing indentation and naming conventions
- **Avoid force-unwrapping:** Use safe unwrapping patterns
- **Clean closures:** Keep closure complexity manageable
- **Error handling:** Implement proper error handling patterns

---

## 🏗️ **Architecture and Separation of Concerns**

### **MVVM Architecture**
- **Views:** Simple, declarative UI components
- **ViewModels:** Business logic and state management
- **Models:** Data structures and domain logic
- **Clear separation:** UI code should not contain business logic

### **DRY Principles**
- **Extract common code:** Create reusable components and utilities
- **Avoid duplication:** Refactor repeated patterns into shared methods
- **Modular design:** Keep components focused and single-purpose
- **Dependency injection:** Prefer over global singletons

### **Vybe-Specific Architecture**
- **Spiritual integrity layer:** Preserve numerological and mystical systems
- **Performance layer:** Maintain 60fps cosmic animations
- **Data layer:** Secure storage of user spiritual data
- **AI integration:** Context-aware insights and guidance

---

## 🚀 **Performance, Memory, and Security**

### **SwiftUI Performance**
- **Break large views:** Reduce render cost with smaller components
- **Use LazyVStack/List:** For dynamic content to render only visible items
- **Target 60fps:** Keep frame render time under ~16ms
- **Profile with Instruments:** Identify and fix performance bottlenecks

### **Memory Management**
- **ARC awareness:** Swift handles most memory automatically
- **Avoid retain cycles:** Use `[weak self]` in closures when needed
- **Efficient data structures:** Choose appropriate collections and algorithms
- **Background processing:** Use async operations for heavy computations

### **Security Best Practices**
- **Keychain storage:** Store sensitive data (tokens, passwords) securely
- **Data protection:** Leverage iOS encryption for files
- **Input validation:** Sanitize all external inputs
- **No hardcoded secrets:** Use configuration files or secure storage

### **Vybe Security Considerations**
- **Spiritual data privacy:** Protect user's spiritual journey information
- **Health data:** Secure handling of HealthKit integration
- **Location data:** Respect user privacy for cosmic match features
- **AI interactions:** Secure API key management

---

## 🔧 **Build Configuration and Testing**

### **Simulator and Device Testing**
- **Default simulator:** iPhone 16 Pro Max for UI testing
- **Release mode testing:** Always test final builds in Release configuration
- **Multiple devices:** Test on different screen sizes when relevant
- **Real device validation:** Test critical features on physical devices

### **Build Standards**
- **Consistent settings:** Match project's Swift version and optimization levels
- **Code signing:** Maintain proper provisioning profiles
- **Deployment target:** Keep updated to project's minimum iOS version
- **CI/CD compatibility:** Ensure builds work in automated environments

### **Testing Protocol**
- **Unit tests:** Run full test suite after each change (currently 434/434 passing)
- **Test Architecture:** Use TestableHybridPostRepository and SimpleMockPostRepository for isolation
- **Behavior Tests:** Focus on user experience, not implementation details
- **Performance tests:** Dedicated performance test suite with manual timing (no measure{} blocks)
- **UI tests:** Validate user interactions and flows
- **Regression testing:** Verify existing functionality still works

---

## ✅ **Post-Change Verification**

### **Quality Assurance Checklist**
- [ ] **Code compiles** without warnings or errors
- [ ] **Tests pass** (unit and UI tests)
- [ ] **Performance maintained** (60fps target)
- [ ] **UI tested** on iPhone 16 Pro Max simulator
- [ ] **Comments updated** and accurate
- [ ] **Documentation** reflects changes

### **Testing Assignment Protocol**
**Always end by asking:** "Who should test this change – you or Claude?"

**If user will test:**
- Provide step-by-step testing instructions
- Cover new features and impacted functionality
- Include expected behaviors and edge cases

**If Claude will test:**
- Summarize changes made
- Explain validation approach
- Report results and any issues found

### **Vybe-Specific Testing**
- **Spiritual accuracy:** Verify numerological calculations remain correct
- **Cosmic animations:** Ensure scroll-safe performance
- **Match detection:** Test cosmic synchronicity features
- **User experience:** Validate spiritual engagement flows

---

## 📚 **Documentation and Maintenance**

### **CLAUDE.md Maintenance**
- **Update after each sprint** with new conventions or adjustments
- **Version control:** Commit changes with descriptive messages
- **Team collaboration:** Review updates during planning sessions
- **Living document:** Treat as evolving project documentation

### **Commit Message Format**
```
docs: update CLAUDE.md for Sprint X
- Added new performance guidelines
- Updated testing protocols
- Enhanced spiritual integrity rules
```

### **Documentation Standards**
- **Clear formatting:** Use proper markdown structure
- **Regular reviews:** Keep content current and relevant
- **Cross-references:** Link to related documentation
- **Examples:** Include code examples where helpful

---

## 🌌 **Vybe-Specific Guidelines**

### **Spiritual Integrity Protection**
- **Preserve numerology:** Never alter core numerological algorithms
- **Sacred correspondences:** Maintain chakra, color, and element mappings
- **Master numbers:** Keep 11, 22, 33, 44 unreduced in calculations
- **Mystical authenticity:** Ensure spiritual content remains genuine

### **Cosmic Animation Standards**
- **Scroll-safe performance:** 60fps during all interactions
- **Sacred geometry:** Preserve spiritual meaning in visual elements
- **Animation timing:** Follow documented standards (2-3s pulses, etc.)
- **Memory efficiency:** Optimize for smooth cosmic experiences

### **User Experience Philosophy**
- **Spiritual engagement:** Enhance user's cosmic connection
- **Peaceful interactions:** Avoid jarring or aggressive animations
- **Accessibility:** Make spiritual features available to all users
- **Performance:** Never compromise smooth experience for features

---

## 🔄 **Continuous Improvement**

### **Regular Reviews**
- **Sprint retrospectives:** Update rules based on lessons learned
- **Performance analysis:** Adjust guidelines based on metrics
- **User feedback:** Incorporate insights from spiritual community
- **Technology updates:** Adapt to new SwiftUI and iOS features

### **Rule Evolution**
- **Team input:** Collaborate on rule updates and additions
- **Best practices:** Stay current with Apple and community standards
- **Project growth:** Scale guidelines as Vybe expands
- **AI assistance:** Optimize rules for effective Claude collaboration

---

## 📖 **Sources and References**

This document incorporates guidelines and best practices from:
- **Apple's Human Interface Guidelines** for UI consistency
- **Swift API Design Guidelines** for code standards
- **SwiftUI Performance Tips** from Apple documentation
- **Swift Memory Management** best practices
- **iOS Security Guidelines** for data protection
- **Vybe Project Documentation** for spiritual integrity requirements

---

*This document serves as the definitive guide for Claude's contributions to VybeMVP, ensuring consistent, high-quality development that honors both technical excellence and spiritual authenticity.* 🌟

## Build & Test Process
- **NEVER commit code without user confirmation**
- User must test on real device before any git commits
- Only commit after user explicitly confirms the build works
- Always run build/lint commands before suggesting commits

## Code Quality
- Always check imports when using UI functions (e.g., SwiftUI for withAnimation)
- Maintain existing code style and patterns
- Test thoroughly before marking tasks complete
- Follow Phase 18 test architecture patterns for new test development
- Add comprehensive documentation comments explaining problems and solutions

## Memory
- **Build Testing:** Test suite now reliable with 434/434 passing - timeouts resolved via Phase 18 fixes
- **NO MORE DerivedData deletions without my explicit approval**
- **Test Architecture:** Use TestableHybridPostRepository for isolated testing without production impact